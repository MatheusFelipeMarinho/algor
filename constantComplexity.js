/**
 * COMPLEXIDADE CONSTANTE - O(1)
 *
 * Algoritmos com complexidade O(1) executam em tempo constante,
 * independente do tamanho da entrada. O tempo de execu√ß√£o √© sempre o mesmo.
 *
 * Caracter√≠sticas:
 * - Tempo de execu√ß√£o fixo e previs√≠vel
 * - N√£o depende do tamanho da entrada
 * - Extremamente eficiente
 * - Opera√ß√µes diretas, sem loops
 *
 * Exemplos comuns:
 * - Acesso direto a elemento de array por √≠ndice
 * - Opera√ß√µes aritm√©ticas simples
 * - Atribui√ß√µes de vari√°veis
 * - Acesso a propriedades de objetos
 * - Push/Pop em pilhas
 */

/**
 * Classe demonstrando a diferen√ßa entre O(1) e O(n)
 */
class ComplexityComparison {
    constructor() {
        this.operationCount = 0;
    }

    resetCounter() {
        this.operationCount = 0;
    }

    getOperationCount() {
        return this.operationCount;
    }

    /**
     * EXEMPLO 1: Console.log com O(1)
     * Executa UMA VEZ, independente do tamanho do array
     * @param {Array} arr - Array de qualquer tamanho
     */
    consoleLogO1(arr) {
        console.log("\nüîπ EXEMPLO O(1) - Console.log FORA do loop");
        console.log("‚îÅ".repeat(60));
        console.log(`Array tem ${arr.length} elementos`);
        console.log("Executando console.log UMA VEZ...\n");

        this.resetCounter();
        const start = performance.now();

        // O(1) - Executa apenas 1 vez, n√£o importa o tamanho do array
        console.log("   ‚úÖ Isso √© O(1) - executou apenas 1 vez!");
        this.operationCount++;

        const end = performance.now();

        console.log(`\nüìä Estat√≠sticas:`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);
        console.log(`   Tempo: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(1) - CONSTANTE\n`);
    }

    /**
     * EXEMPLO 2: Console.log com O(n)
     * Executa N VEZES, proporcional ao tamanho do array
     * @param {Array} arr - Array de qualquer tamanho
     */
    consoleLogOn(arr) {
        console.log("\nüîπ EXEMPLO O(n) - Console.log DENTRO do loop");
        console.log("‚îÅ".repeat(60));
        console.log(`Array tem ${arr.length} elementos`);
        console.log("Executando console.log PARA CADA elemento...\n");

        this.resetCounter();
        const start = performance.now();

        // O(n) - Executa N vezes (uma para cada elemento)
        for (let i = 0; i < arr.length; i++) {
            console.log(`   üîÑ Itera√ß√£o ${i + 1}: ${arr[i]}`);
            this.operationCount++;
        }

        const end = performance.now();

        console.log(`\nüìä Estat√≠sticas:`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);
        console.log(`   Tempo: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(n) - LINEAR\n`);
    }

    /**
     * Compara√ß√£o direta entre O(1) e O(n)
     * @param {Array} arr - Array de teste
     */
    compararComplexidades(arr) {
        console.log("\n" + "‚ïê".repeat(70));
        console.log("      COMPARA√á√ÉO: O(1) vs O(n) com console.log");
        console.log("‚ïê".repeat(70));

        console.log(`\nArray de teste: [${arr.join(", ")}]`);
        console.log(`Tamanho: ${arr.length} elementos\n`);

        // Teste O(1)
        this.consoleLogO1(arr);

        // Teste O(n)
        this.consoleLogOn(arr);

        // Resumo
        console.log("‚ïê".repeat(70));
        console.log("üìà CONCLUS√ÉO:");
        console.log("‚ïê".repeat(70));
        console.log("\n‚úÖ O(1) - Tempo Constante:");
        console.log("   ‚Ä¢ Executou 1 vez (n√£o importa o tamanho do array)");
        console.log("   ‚Ä¢ Sempre o mesmo tempo de execu√ß√£o");
        console.log("   ‚Ä¢ Extremamente eficiente\n");

        console.log("üîÑ O(n) - Tempo Linear:");
        console.log(`   ‚Ä¢ Executou ${arr.length} vezes (uma para cada elemento)`);
        console.log("   ‚Ä¢ Tempo cresce com o tamanho do array");
        console.log(`   ‚Ä¢ Se dobrar o array, dobra o tempo\n`);
    }
}

/**
 * Classe com opera√ß√µes de complexidade O(1)
 */
class ConstantComplexity {
    constructor() {
        this.cache = new Map();
        this.stack = [];
        this.userData = {};
    }

    /**
     * 1. ACESSO POR √çNDICE - O(1)
     * Acessar elemento em posi√ß√£o espec√≠fica √© sempre O(1)
     * @param {Array} arr - Array qualquer
     * @param {number} index - √çndice a acessar
     * @returns {*} Elemento na posi√ß√£o
     */
    acessarPorIndice(arr, index) {
        console.log(`\nüî∏ Acessando arr[${index}]...`);

        const start = performance.now();
        const elemento = arr[index]; // O(1) - acesso direto
        const end = performance.now();

        console.log(`   Resultado: ${elemento}`);
        console.log(`   Tempo: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(1)`);

        return elemento;
    }

    /**
     * 2. OPERA√á√ïES ARITM√âTICAS - O(1)
     * C√°lculos matem√°ticos simples s√£o sempre O(1)
     * @param {number} a - Primeiro n√∫mero
     * @param {number} b - Segundo n√∫mero
     * @returns {Object} Resultados das opera√ß√µes
     */
    operacoesAritmeticas(a, b) {
        console.log(`\nüî∏ Opera√ß√µes aritm√©ticas: ${a} e ${b}`);

        const start = performance.now();

        const soma = a + b;        // O(1)
        const subtracao = a - b;   // O(1)
        const multiplicacao = a * b; // O(1)
        const divisao = a / b;     // O(1)

        const end = performance.now();

        console.log(`   Soma: ${soma}`);
        console.log(`   Subtra√ß√£o: ${subtracao}`);
        console.log(`   Multiplica√ß√£o: ${multiplicacao}`);
        console.log(`   Divis√£o: ${divisao.toFixed(2)}`);
        console.log(`   Tempo total: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(1) para cada opera√ß√£o`);

        return { soma, subtracao, multiplicacao, divisao };
    }

    /**
     * 3. PUSH/POP EM PILHA - O(1)
     * Adicionar/remover do final do array √© O(1)
     * @param {*} elemento - Elemento a adicionar
     */
    pilhaOperacoes(elemento) {
        console.log(`\nüî∏ Opera√ß√µes de Pilha (Stack)`);

        // Push - O(1)
        const startPush = performance.now();
        this.stack.push(elemento);
        const endPush = performance.now();

        console.log(`   Push "${elemento}": ${(endPush - startPush).toFixed(6)}ms - O(1)`);

        // Pop - O(1)
        const startPop = performance.now();
        const removido = this.stack.pop();
        const endPop = performance.now();

        console.log(`   Pop "${removido}": ${(endPop - startPop).toFixed(6)}ms - O(1)`);
        console.log(`   Pilha atual: [${this.stack.join(", ")}]`);
    }

    /**
     * 4. ACESSO A PROPRIEDADE DE OBJETO - O(1)
     * Acessar propriedade de objeto por chave √© O(1)
     * @param {string} chave - Chave a acessar
     * @param {*} valor - Valor a armazenar
     */
    acessoObjeto(chave, valor) {
        console.log(`\nüî∏ Acesso a Objeto`);

        // Definir - O(1)
        const startSet = performance.now();
        this.userData[chave] = valor;
        const endSet = performance.now();

        console.log(`   Set userData["${chave}"] = "${valor}": ${(endSet - startSet).toFixed(6)}ms - O(1)`);

        // Obter - O(1)
        const startGet = performance.now();
        const resultado = this.userData[chave];
        const endGet = performance.now();

        console.log(`   Get userData["${chave}"] = "${resultado}": ${(endGet - startGet).toFixed(6)}ms - O(1)`);
    }

    /**
     * 5. MAP/CACHE - O(1)
     * Opera√ß√µes em Map s√£o O(1) em m√©dia
     * @param {string} chave - Chave do cache
     * @param {*} valor - Valor a cachear
     */
    operacoesCache(chave, valor) {
        console.log(`\nüî∏ Opera√ß√µes de Cache (Map)`);

        // Set - O(1)
        const startSet = performance.now();
        this.cache.set(chave, valor);
        const endSet = performance.now();

        console.log(`   Cache.set("${chave}", "${valor}"): ${(endSet - startSet).toFixed(6)}ms - O(1)`);

        // Get - O(1)
        const startGet = performance.now();
        const resultado = this.cache.get(chave);
        const endGet = performance.now();

        console.log(`   Cache.get("${chave}"): "${resultado}" - ${(endGet - startGet).toFixed(6)}ms - O(1)`);

        // Has - O(1)
        const startHas = performance.now();
        const existe = this.cache.has(chave);
        const endHas = performance.now();

        console.log(`   Cache.has("${chave}"): ${existe} - ${(endHas - startHas).toFixed(6)}ms - O(1)`);
    }

    /**
     * 6. PRIMEIRO E √öLTIMO ELEMENTO - O(1)
     * Acessar primeiro ou √∫ltimo elemento √© sempre O(1)
     * @param {Array} arr - Array qualquer
     */
    primeiroEUltimo(arr) {
        console.log(`\nüî∏ Acesso a Primeiro e √öltimo Elemento`);

        const start = performance.now();

        const primeiro = arr[0];              // O(1)
        const ultimo = arr[arr.length - 1];   // O(1)

        const end = performance.now();

        console.log(`   Primeiro: ${primeiro}`);
        console.log(`   √öltimo: ${ultimo}`);
        console.log(`   Tempo: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(1) para ambos`);

        return { primeiro, ultimo };
    }

    /**
     * 7. VERIFICAR TAMANHO - O(1)
     * Propriedade length √© mantida e acessada em O(1)
     * @param {Array} arr - Array qualquer
     */
    verificarTamanho(arr) {
        console.log(`\nüî∏ Verificar Tamanho do Array`);

        const start = performance.now();
        const tamanho = arr.length; // O(1)
        const end = performance.now();

        console.log(`   Tamanho: ${tamanho} elementos`);
        console.log(`   Tempo: ${(end - start).toFixed(6)}ms`);
        console.log(`   Complexidade: O(1)`);

        return tamanho;
    }

    /**
     * USE CASE: Sistema de Cache para API
     * Demonstra uso pr√°tico de opera√ß√µes O(1)
     */
    useCaseCache() {
        console.log("\n" + "‚ïê".repeat(70));
        console.log("      USE CASE: SISTEMA DE CACHE PARA API");
        console.log("‚ïê".repeat(70));

        console.log("\nüìù Cen√°rio:");
        console.log("   Uma API precisa armazenar resultados de consultas");
        console.log("   frequentes para evitar processamento repetido.\n");

        // Simular consultas
        const consultas = [
            { id: "user:123", dados: { nome: "Jo√£o", idade: 30 } },
            { id: "user:456", dados: { nome: "Maria", idade: 25 } },
            { id: "product:789", dados: { nome: "Notebook", preco: 3000 } }
        ];

        console.log("1Ô∏è‚É£  Armazenando no cache (O(1) cada):");
        consultas.forEach(consulta => {
            const start = performance.now();
            this.cache.set(consulta.id, consulta.dados); // O(1)
            const end = performance.now();
            console.log(`   ‚úÖ ${consulta.id}: ${(end - start).toFixed(6)}ms`);
        });

        console.log("\n2Ô∏è‚É£  Buscando no cache (O(1) cada):");
        ["user:123", "product:789", "user:999"].forEach(id => {
            const start = performance.now();
            const resultado = this.cache.get(id); // O(1)
            const end = performance.now();

            if (resultado) {
                console.log(`   ‚úÖ ${id}: ENCONTRADO - ${(end - start).toFixed(6)}ms`);
                console.log(`      Dados: ${JSON.stringify(resultado)}`);
            } else {
                console.log(`   ‚ùå ${id}: N√ÉO ENCONTRADO - ${(end - start).toFixed(6)}ms`);
            }
        });

        console.log("\nüí° Benef√≠cios do O(1):");
        console.log("   ‚Ä¢ Tempo constante independente do n√∫mero de itens no cache");
        console.log("   ‚Ä¢ Extremamente r√°pido mesmo com milh√µes de entradas");
        console.log("   ‚Ä¢ Ideal para sistemas de alta performance");
    }
}

/**
 * Demonstra√ß√£o completa
 */
function demonstrarComplexidadeConstante() {
    console.log("‚ïê".repeat(70));
    console.log("      DEMONSTRA√á√ÉO DE COMPLEXIDADE CONSTANTE - O(1)");
    console.log("‚ïê".repeat(70));

    const constante = new ConstantComplexity();

    // Exemplo 1: Acesso por √≠ndice
    console.log("\nüî∏ EXEMPLO 1: Acesso por √çndice");
    console.log("‚îÅ".repeat(60));
    const array1 = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
    console.log(`Array: [${array1.join(", ")}]`);
    constante.acessarPorIndice(array1, 5);
    constante.acessarPorIndice(array1, 0);
    constante.acessarPorIndice(array1, 9);

    // Exemplo 2: Opera√ß√µes aritm√©ticas
    console.log("\n\nüî∏ EXEMPLO 2: Opera√ß√µes Aritm√©ticas");
    console.log("‚îÅ".repeat(60));
    constante.operacoesAritmeticas(50, 10);

    // Exemplo 3: Pilha
    console.log("\n\nüî∏ EXEMPLO 3: Opera√ß√µes de Pilha");
    console.log("‚îÅ".repeat(60));
    constante.pilhaOperacoes("A");
    constante.pilhaOperacoes("B");
    constante.pilhaOperacoes("C");

    // Exemplo 4: Objeto
    console.log("\n\nüî∏ EXEMPLO 4: Acesso a Objeto");
    console.log("‚îÅ".repeat(60));
    constante.acessoObjeto("nome", "Jo√£o Silva");
    constante.acessoObjeto("email", "joao@email.com");

    // Exemplo 5: Cache
    console.log("\n\nüî∏ EXEMPLO 5: Opera√ß√µes de Cache");
    console.log("‚îÅ".repeat(60));
    constante.operacoesCache("chave1", "valor1");
    constante.operacoesCache("config", { theme: "dark", lang: "pt" });

    // Exemplo 6: Primeiro e √∫ltimo
    console.log("\n\nüî∏ EXEMPLO 6: Primeiro e √öltimo Elemento");
    console.log("‚îÅ".repeat(60));
    const array2 = Array.from({ length: 1000 }, (_, i) => i);
    console.log(`Array com ${array2.length} elementos`);
    constante.primeiroEUltimo(array2);

    // Exemplo 7: Tamanho
    console.log("\n\nüî∏ EXEMPLO 7: Verificar Tamanho");
    console.log("‚îÅ".repeat(60));
    constante.verificarTamanho(array2);
}

/**
 * Compara√ß√£o visual com diferentes tamanhos
 */
function compararTamanhos() {
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("      PROVA: O(1) N√ÉO DEPENDE DO TAMANHO");
    console.log("‚ïê".repeat(70));

    const tamanhos = [10, 100, 1000, 10000, 100000];

    console.log("\nTestando acesso por √≠ndice com arrays de diferentes tamanhos:\n");
    console.log("Tamanho".padEnd(15) + "Tempo (ms)".padEnd(20) + "Observa√ß√£o");
    console.log("‚îÄ".repeat(70));

    tamanhos.forEach(tamanho => {
        const arr = Array.from({ length: tamanho }, (_, i) => i);

        const start = performance.now();
        const elemento = arr[5]; // O(1) - sempre acessa √≠ndice 5
        const end = performance.now();

        const tempo = (end - start).toFixed(6);

        console.log(
            tamanho.toString().padEnd(15) +
            tempo.padEnd(20) +
            "Tempo constante!"
        );
    });

    console.log("\nüí° Observe que o tempo permanece praticamente o mesmo!");
    console.log("   Isso √© O(1) - CONSTANTE - n√£o importa o tamanho do array!");
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXECU√á√ÉO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// 1. Compara√ß√£o console.log O(1) vs O(n)
const comparison = new ComplexityComparison();

console.log("\n" + "‚ïê".repeat(70));
console.log("      PARTE 1: DIFEREN√áA VISUAL ENTRE O(1) E O(n)");
console.log("‚ïê".repeat(70));

// Array pequeno
comparison.compararComplexidades([1, 2, 3, 4, 5]);

// Array maior
console.log("\n\n");
comparison.compararComplexidades([10, 20, 30, 40, 50, 60, 70, 80]);

// 2. Demonstra√ß√£o de opera√ß√µes O(1)
console.log("\n\n" + "‚ïê".repeat(70));
console.log("      PARTE 2: OPERA√á√ïES COM COMPLEXIDADE O(1)");
console.log("‚ïê".repeat(70));

demonstrarComplexidadeConstante();

// 3. Use Case pr√°tico
const constante = new ConstantComplexity();
constante.useCaseCache();

// 4. Compara√ß√£o de tamanhos
compararTamanhos();

// Resumo Final
console.log("\n\n" + "‚ïê".repeat(70));
console.log("      RESUMO: COMPLEXIDADE CONSTANTE O(1)");
console.log("‚ïê".repeat(70));

console.log("\n‚úÖ Caracter√≠sticas:");
console.log("   ‚Ä¢ Tempo de execu√ß√£o FIXO e PREVIS√çVEL");
console.log("   ‚Ä¢ N√ÉO depende do tamanho da entrada");
console.log("   ‚Ä¢ Opera√ß√£o mais eficiente poss√≠vel");
console.log("   ‚Ä¢ Sem loops, acesso direto");

console.log("\nüìä Exemplos O(1):");
console.log("   ‚Ä¢ Acesso a array por √≠ndice: arr[5]");
console.log("   ‚Ä¢ Opera√ß√µes aritm√©ticas: a + b, a * b");
console.log("   ‚Ä¢ Push/Pop em array (final)");
console.log("   ‚Ä¢ Acesso a propriedades de objeto: obj.prop");
console.log("   ‚Ä¢ Map.get(), Map.set(), Map.has()");
console.log("   ‚Ä¢ Array.length");
console.log("   ‚Ä¢ console.log() FORA de loop");

console.log("\n‚ùå N√ÉO s√£o O(1):");
console.log("   ‚Ä¢ Array.shift() - remove do in√≠cio (O(n))");
console.log("   ‚Ä¢ Array.unshift() - adiciona no in√≠cio (O(n))");
console.log("   ‚Ä¢ Array.indexOf() - busca linear (O(n))");
console.log("   ‚Ä¢ Array.sort() - ordena√ß√£o (O(n log n))");
console.log("   ‚Ä¢ console.log() DENTRO de loop (O(n))");

console.log("\nüéØ Quando usar:");
console.log("   ‚Ä¢ Sempre que poss√≠vel!");
console.log("   ‚Ä¢ Sistemas de cache");
console.log("   ‚Ä¢ Acesso r√°pido a dados");
console.log("   ‚Ä¢ Estruturas de dados eficientes (Hash Tables, Maps)");

console.log("\nüí° Dica de Ouro:");
console.log("   Se voc√™ pode resolver em O(1), SEMPRE escolha O(1)!");
console.log("   √â a melhor complexidade poss√≠vel.");

console.log("\n" + "‚ïê".repeat(70));
