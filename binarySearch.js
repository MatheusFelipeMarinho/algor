/**
 * BINARY SEARCH - Algoritmo de Busca Bin√°ria
 *
 * A Busca Bin√°ria √© um algoritmo eficiente para encontrar um elemento em uma
 * lista ORDENADA. O algoritmo divide repetidamente o intervalo de busca pela
 * metade, comparando o elemento do meio com o valor procurado.
 *
 * ‚ö†Ô∏è IMPORTANTE: O array DEVE estar ordenado para funcionar corretamente!
 *
 * Complexidade:
 * - Melhor caso: O(1) - elemento est√° no meio
 * - Caso m√©dio: O(log n)
 * - Pior caso: O(log n)
 * - Espa√ßo: O(1) para iterativa, O(log n) para recursiva (pilha de chamadas)
 *
 * Vantagens sobre busca linear:
 * - Muito mais r√°pido para grandes arrays
 * - Exemplo: array com 1.000.000 elementos
 *   ‚Ä¢ Busca Linear: at√© 1.000.000 compara√ß√µes
 *   ‚Ä¢ Busca Bin√°ria: no m√°ximo 20 compara√ß√µes
 */

/**
 * Binary Search - Vers√£o Iterativa
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor a ser encontrado
 * @returns {number} √çndice do elemento ou -1 se n√£o encontrado
 */
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        // Calcula o √≠ndice do meio (evita overflow)
        const mid = Math.floor(left + (right - left) / 2);

        // Verifica se encontrou o elemento
        if (arr[mid] === target) {
            return mid;
        }

        // Se o elemento do meio √© menor, ignora a metade esquerda
        if (arr[mid] < target) {
            left = mid + 1;
        }
        // Se o elemento do meio √© maior, ignora a metade direita
        else {
            right = mid - 1;
        }
    }

    // Elemento n√£o encontrado
    return -1;
}

/**
 * Binary Search - Vers√£o Recursiva
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor a ser encontrado
 * @param {number} left - √çndice inicial (padr√£o: 0)
 * @param {number} right - √çndice final (padr√£o: arr.length - 1)
 * @returns {number} √çndice do elemento ou -1 se n√£o encontrado
 */
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
    // Caso base: elemento n√£o encontrado
    if (left > right) {
        return -1;
    }

    // Calcula o √≠ndice do meio
    const mid = Math.floor(left + (right - left) / 2);

    // Verifica se encontrou o elemento
    if (arr[mid] === target) {
        return mid;
    }

    // Busca recursiva na metade esquerda ou direita
    if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

/**
 * Binary Search com visualiza√ß√£o passo a passo
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor a ser encontrado
 * @returns {number} √çndice do elemento ou -1 se n√£o encontrado
 */
function binarySearchVisualized(arr, target) {
    console.log("\nüîç BINARY SEARCH - VISUALIZA√á√ÉO PASSO A PASSO üîç\n");
    console.log("Array ordenado:", arr);
    console.log(`Procurando por: ${target}`);
    console.log("‚îÅ".repeat(60));

    let left = 0;
    let right = arr.length - 1;
    let step = 1;
    let comparisons = 0;

    while (left <= right) {
        const mid = Math.floor(left + (right - left) / 2);
        comparisons++;

        console.log(`\nüìç Passo ${step}:`);
        console.log(`   Intervalo de busca: √≠ndices [${left}...${right}]`);
        console.log(`   Valores no intervalo: [${arr.slice(left, right + 1).join(", ")}]`);
        console.log(`   √çndice do meio: ${mid}`);
        console.log(`   Valor do meio: ${arr[mid]}`);

        // Visualiza√ß√£o do array com marcadores
        const visualization = arr.map((val, idx) => {
            if (idx === mid) return `[${val}]`; // Elemento do meio
            if (idx >= left && idx <= right) return ` ${val} `; // Dentro do intervalo
            return ` ¬∑ `; // Fora do intervalo
        });
        console.log(`   Array: ${visualization.join("")}`);

        if (arr[mid] === target) {
            console.log(`   ‚úÖ ENCONTRADO! O valor ${target} est√° no √≠ndice ${mid}`);
            console.log("\n" + "‚îÅ".repeat(60));
            console.log(`üìä Estat√≠sticas:`);
            console.log(`   ‚Ä¢ Compara√ß√µes: ${comparisons}`);
            console.log(`   ‚Ä¢ Passos: ${step}`);
            console.log(`   ‚Ä¢ √çndice encontrado: ${mid}`);
            return mid;
        }

        if (arr[mid] < target) {
            console.log(`   üîº ${arr[mid]} < ${target} ‚Üí Buscar na metade DIREITA`);
            left = mid + 1;
        } else {
            console.log(`   üîΩ ${arr[mid]} > ${target} ‚Üí Buscar na metade ESQUERDA`);
            right = mid - 1;
        }

        step++;
    }

    console.log(`\n   ‚ùå N√ÉO ENCONTRADO! O valor ${target} n√£o est√° no array`);
    console.log("\n" + "‚îÅ".repeat(60));
    console.log(`üìä Estat√≠sticas:`);
    console.log(`   ‚Ä¢ Compara√ß√µes: ${comparisons}`);
    console.log(`   ‚Ä¢ Passos: ${step - 1}`);

    return -1;
}

/**
 * Busca o primeiro elemento maior ou igual ao target (Lower Bound)
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor de refer√™ncia
 * @returns {number} √çndice do primeiro elemento >= target, ou arr.length se n√£o existir
 */
function lowerBound(arr, target) {
    let left = 0;
    let right = arr.length;

    while (left < right) {
        const mid = Math.floor(left + (right - left) / 2);

        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

/**
 * Busca o primeiro elemento maior que o target (Upper Bound)
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor de refer√™ncia
 * @returns {number} √çndice do primeiro elemento > target, ou arr.length se n√£o existir
 */
function upperBound(arr, target) {
    let left = 0;
    let right = arr.length;

    while (left < right) {
        const mid = Math.floor(left + (right - left) / 2);

        if (arr[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left;
}

/**
 * Encontra todas as ocorr√™ncias de um valor (para arrays com duplicatas)
 * @param {number[]} arr - Array ordenado de n√∫meros
 * @param {number} target - Valor a ser encontrado
 * @returns {number[]} Array com todos os √≠ndices onde o valor aparece
 */
function binarySearchAll(arr, target) {
    const first = lowerBound(arr, target);

    if (first >= arr.length || arr[first] !== target) {
        return [];
    }

    const last = upperBound(arr, target);
    const indices = [];

    for (let i = first; i < last; i++) {
        indices.push(i);
    }

    return indices;
}

/**
 * Demonstra√ß√£o completa do Binary Search
 */
function demonstrarBinarySearch() {
    console.log("‚ïê".repeat(70));
    console.log("         DEMONSTRA√á√ÉO DO ALGORITMO BINARY SEARCH");
    console.log("‚ïê".repeat(70));

    // Exemplo 1: Busca bem-sucedida (elemento no meio)
    console.log("\nüî∏ EXEMPLO 1: Elemento no Meio");
    const arr1 = [1, 3, 5, 7, 9, 11, 13, 15, 17];
    binarySearchVisualized(arr1, 9);

    // Exemplo 2: Busca bem-sucedida (elemento no in√≠cio)
    console.log("\n\nüî∏ EXEMPLO 2: Elemento no In√≠cio");
    const arr2 = [2, 4, 6, 8, 10, 12, 14, 16];
    binarySearchVisualized(arr2, 2);

    // Exemplo 3: Busca bem-sucedida (elemento no final)
    console.log("\n\nüî∏ EXEMPLO 3: Elemento no Final");
    const arr3 = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
    binarySearchVisualized(arr3, 50);

    // Exemplo 4: Busca sem sucesso
    console.log("\n\nüî∏ EXEMPLO 4: Elemento N√£o Existe");
    const arr4 = [1, 3, 5, 7, 9, 11, 13];
    binarySearchVisualized(arr4, 6);

    // Exemplo 5: Array com duplicatas
    console.log("\n\nüî∏ EXEMPLO 5: Array com Elementos Duplicados");
    const arr5 = [1, 2, 2, 2, 3, 4, 5, 5, 5, 6];
    console.log("Array:", arr5);
    console.log(`Procurando todas as ocorr√™ncias de 2:`);
    const indices2 = binarySearchAll(arr5, 2);
    console.log(`   Encontrado nos √≠ndices: [${indices2.join(", ")}]`);
    console.log(`Procurando todas as ocorr√™ncias de 5:`);
    const indices5 = binarySearchAll(arr5, 5);
    console.log(`   Encontrado nos √≠ndices: [${indices5.join(", ")}]`);

    // Compara√ß√£o: Iterativa vs Recursiva
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("      COMPARA√á√ÉO: Binary Search Iterativa vs Recursiva");
    console.log("‚ïê".repeat(70));

    const testArray = Array.from({length: 1000}, (_, i) => i * 2);
    const searchValue = 1234;

    console.log(`\nArray de teste: ${testArray.length} elementos [0, 2, 4, ..., 1998]`);
    console.log(`Procurando por: ${searchValue}`);

    // Teste iterativo
    const start1 = performance.now();
    const result1 = binarySearch(testArray, searchValue);
    const end1 = performance.now();

    // Teste recursivo
    const start2 = performance.now();
    const result2 = binarySearchRecursive(testArray, searchValue);
    const end2 = performance.now();

    console.log(`\n‚úÖ Vers√£o Iterativa:`);
    console.log(`   Resultado: √≠ndice ${result1}`);
    console.log(`   Tempo: ${(end1 - start1).toFixed(6)}ms`);

    console.log(`\n‚úÖ Vers√£o Recursiva:`);
    console.log(`   Resultado: √≠ndice ${result2}`);
    console.log(`   Tempo: ${(end2 - start2).toFixed(6)}ms`);

    // Compara√ß√£o com busca linear
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("      COMPARA√á√ÉO: Binary Search vs Busca Linear");
    console.log("‚ïê".repeat(70));

    const linearSearch = (arr, target) => {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === target) return i;
        }
        return -1;
    };

    const bigArray = Array.from({length: 1000000}, (_, i) => i);
    const searchFor = 999999;

    console.log(`\nArray de teste: ${bigArray.length.toLocaleString()} elementos`);
    console.log(`Procurando por: ${searchFor}`);

    const startLinear = performance.now();
    const resultLinear = linearSearch(bigArray, searchFor);
    const endLinear = performance.now();

    const startBinary = performance.now();
    const resultBinary = binarySearch(bigArray, searchFor);
    const endBinary = performance.now();

    console.log(`\nüìä Busca Linear:`);
    console.log(`   Resultado: √≠ndice ${resultLinear}`);
    console.log(`   Tempo: ${(endLinear - startLinear).toFixed(6)}ms`);

    console.log(`\nüöÄ Binary Search:`);
    console.log(`   Resultado: √≠ndice ${resultBinary}`);
    console.log(`   Tempo: ${(endBinary - startBinary).toFixed(6)}ms`);

    const speedup = (endLinear - startLinear) / (endBinary - startBinary);
    console.log(`\n‚ö° Binary Search foi ${speedup.toFixed(1)}x mais r√°pido!`);
}

/**
 * Exemplos pr√°ticos de uso
 */
function exemplosPraticos() {
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("               EXEMPLOS PR√ÅTICOS DE USO");
    console.log("‚ïê".repeat(70));

    // Busca em lista de pre√ßos
    console.log("\nüì¶ Exemplo 1: Busca em Lista de Pre√ßos");
    const precos = [10, 25, 30, 45, 50, 75, 100, 150, 200];
    const precoProcurado = 50;
    console.log(`Pre√ßos dispon√≠veis: [${precos.join(", ")}]`);
    console.log(`Procurando pre√ßo: ${precoProcurado}`);
    const idx1 = binarySearch(precos, precoProcurado);
    console.log(`Resultado: ${idx1 !== -1 ? `Encontrado no √≠ndice ${idx1}` : "N√£o encontrado"}`);

    // Busca em lista de IDs
    console.log("\nüÜî Exemplo 2: Verificar se ID existe");
    const ids = [101, 205, 310, 415, 520, 625, 730, 835, 940];
    const idProcurado = 415;
    console.log(`IDs cadastrados: [${ids.join(", ")}]`);
    console.log(`Verificando ID: ${idProcurado}`);
    const existe = binarySearch(ids, idProcurado) !== -1;
    console.log(`Resultado: ID ${existe ? "‚úÖ existe" : "‚ùå n√£o existe"} no sistema`);

    // Lower e Upper Bound
    console.log("\nüìä Exemplo 3: Lower Bound e Upper Bound");
    const notas = [5.5, 6.0, 6.5, 7.0, 7.0, 7.0, 8.0, 8.5, 9.0, 9.5];
    const notaMinima = 7.0;
    console.log(`Notas: [${notas.join(", ")}]`);
    console.log(`Nota m√≠nima para aprova√ß√£o: ${notaMinima}`);
    const primeiroAprovado = lowerBound(notas, notaMinima);
    const totalAprovados = notas.length - primeiroAprovado;
    console.log(`Total de aprovados: ${totalAprovados} alunos`);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXECU√á√ÉO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

demonstrarBinarySearch();
exemplosPraticos();

// Resumo final
console.log("\n\n" + "‚ïê".repeat(70));
console.log("                         RESUMO");
console.log("‚ïê".repeat(70));
console.log(`
üìö QUANDO USAR BINARY SEARCH:
   ‚úÖ Array est√° ORDENADO
   ‚úÖ Precisa buscar elementos rapidamente
   ‚úÖ Array √© grande (muitos elementos)
   ‚úÖ Far√° m√∫ltiplas buscas no mesmo array

‚ùå QUANDO N√ÉO USAR:
   ‚ùå Array n√£o est√° ordenado (use busca linear ou ordene primeiro)
   ‚ùå Array muito pequeno (<10 elementos) - busca linear √© suficiente
   ‚ùå Vai fazer apenas uma busca (custo de ordena√ß√£o n√£o compensa)

üéØ COMPLEXIDADE:
   Tempo: O(log n) - extremamente eficiente!
   Espa√ßo: O(1) iterativa | O(log n) recursiva

üí° DICA:
   Para 1.000.000 de elementos:
   ‚Ä¢ Busca Linear: at√© 1.000.000 compara√ß√µes
   ‚Ä¢ Binary Search: no m√°ximo 20 compara√ß√µes! üöÄ
`);
