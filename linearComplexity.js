/**
 * COMPLEXIDADE LINEAR - O(n)
 *
 * Algoritmos com complexidade O(n) percorrem todos os elementos de uma cole√ß√£o
 * exatamente uma vez. O tempo de execu√ß√£o cresce linearmente com o tamanho da entrada.
 *
 * Caracter√≠sticas:
 * - Tempo de execu√ß√£o proporcional ao tamanho da entrada
 * - Um √∫nico loop sobre os dados
 * - Eficiente para opera√ß√µes simples
 * - Escal√°vel para grandes volumes de dados
 *
 * Exemplos comuns:
 * - Busca linear em array n√£o ordenado
 * - Soma de elementos
 * - Encontrar m√°ximo/m√≠nimo
 * - Filtragem de dados
 * - Transforma√ß√£o de dados (map)
 */

/**
 * Classe com diversos exemplos de opera√ß√µes O(n)
 */
class LinearComplexity {
    constructor() {
        this.operationCount = 0;
    }

    /**
     * Reseta o contador de opera√ß√µes
     */
    resetCounter() {
        this.operationCount = 0;
    }

    /**
     * Retorna o n√∫mero de opera√ß√µes realizadas
     */
    getOperationCount() {
        return this.operationCount;
    }

    /**
     * 1. SOMA DE ELEMENTOS - O(n)
     * Percorre o array uma vez somando todos os elementos
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number} Soma total
     */
    somaElementos(arr) {
        this.resetCounter();
        let soma = 0;

        for (let i = 0; i < arr.length; i++) {
            soma += arr[i];
            this.operationCount++;
        }

        return soma;
    }

    /**
     * 2. ENCONTRAR M√ÅXIMO - O(n)
     * Percorre o array uma vez para encontrar o maior elemento
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number} Maior elemento
     */
    encontrarMaximo(arr) {
        this.resetCounter();

        if (arr.length === 0) return null;

        let maximo = arr[0];

        for (let i = 1; i < arr.length; i++) {
            if (arr[i] > maximo) {
                maximo = arr[i];
            }
            this.operationCount++;
        }

        return maximo;
    }

    /**
     * 3. ENCONTRAR M√çNIMO - O(n)
     * Percorre o array uma vez para encontrar o menor elemento
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number} Menor elemento
     */
    encontrarMinimo(arr) {
        this.resetCounter();

        if (arr.length === 0) return null;

        let minimo = arr[0];

        for (let i = 1; i < arr.length; i++) {
            if (arr[i] < minimo) {
                minimo = arr[i];
            }
            this.operationCount++;
        }

        return minimo;
    }

    /**
     * 4. BUSCA LINEAR - O(n)
     * Procura um elemento espec√≠fico no array
     * @param {Array} arr - Array a ser pesquisado
     * @param {*} target - Elemento a ser encontrado
     * @returns {number} √çndice do elemento ou -1 se n√£o encontrado
     */
    buscaLinear(arr, target) {
        this.resetCounter();

        for (let i = 0; i < arr.length; i++) {
            this.operationCount++;
            if (arr[i] === target) {
                return i;
            }
        }

        return -1;
    }

    /**
     * 5. CONTAR OCORR√äNCIAS - O(n)
     * Conta quantas vezes um elemento aparece no array
     * @param {Array} arr - Array a ser analisado
     * @param {*} elemento - Elemento a ser contado
     * @returns {number} N√∫mero de ocorr√™ncias
     */
    contarOcorrencias(arr, elemento) {
        this.resetCounter();
        let count = 0;

        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === elemento) {
                count++;
            }
            this.operationCount++;
        }

        return count;
    }

    /**
     * 6. FILTRAR PARES - O(n)
     * Retorna apenas os n√∫meros pares do array
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number[]} Array com n√∫meros pares
     */
    filtrarPares(arr) {
        this.resetCounter();
        const pares = [];

        for (let i = 0; i < arr.length; i++) {
            if (arr[i] % 2 === 0) {
                pares.push(arr[i]);
            }
            this.operationCount++;
        }

        return pares;
    }

    /**
     * 7. DUPLICAR VALORES - O(n)
     * Cria um novo array com todos os valores duplicados
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number[]} Array com valores duplicados
     */
    duplicarValores(arr) {
        this.resetCounter();
        const duplicados = [];

        for (let i = 0; i < arr.length; i++) {
            duplicados.push(arr[i] * 2);
            this.operationCount++;
        }

        return duplicados;
    }

    /**
     * 8. REVERTER ARRAY - O(n)
     * Inverte a ordem dos elementos do array
     * @param {Array} arr - Array a ser revertido
     * @returns {Array} Array revertido
     */
    reverterArray(arr) {
        this.resetCounter();
        const revertido = [];

        for (let i = arr.length - 1; i >= 0; i--) {
            revertido.push(arr[i]);
            this.operationCount++;
        }

        return revertido;
    }

    /**
     * 9. CALCULAR M√âDIA - O(n)
     * Calcula a m√©dia aritm√©tica dos elementos
     * @param {number[]} arr - Array de n√∫meros
     * @returns {number} M√©dia dos valores
     */
    calcularMedia(arr) {
        this.resetCounter();

        if (arr.length === 0) return 0;

        let soma = 0;

        for (let i = 0; i < arr.length; i++) {
            soma += arr[i];
            this.operationCount++;
        }

        return soma / arr.length;
    }

    /**
     * 10. REMOVER DUPLICATAS - O(n)
     * Remove elementos duplicados do array (usando Set - O(n) m√©dio)
     * @param {Array} arr - Array com poss√≠veis duplicatas
     * @returns {Array} Array sem duplicatas
     */
    removerDuplicatas(arr) {
        this.resetCounter();
        const vistos = new Set();
        const resultado = [];

        for (let i = 0; i < arr.length; i++) {
            if (!vistos.has(arr[i])) {
                vistos.add(arr[i]);
                resultado.push(arr[i]);
            }
            this.operationCount++;
        }

        return resultado;
    }

    /**
     * USE CASE: AN√ÅLISE DE VENDAS
     * Processa dados de vendas e retorna estat√≠sticas
     * @param {number[]} vendas - Array com valores de vendas di√°rias
     * @returns {Object} Estat√≠sticas das vendas
     */
    analisarVendas(vendas) {
        console.log("\nüìä AN√ÅLISE DE VENDAS - Use Case O(n)\n");
        console.log("Dados de entrada:", vendas);
        console.log("‚îÅ".repeat(60));

        // Todas essas opera√ß√µes s√£o O(n) individualmente
        // Executadas sequencialmente: O(n) + O(n) + O(n) = O(n)

        const total = this.somaElementos(vendas);
        console.log(`\n‚úÖ Total de vendas: R$ ${total.toFixed(2)}`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);

        const media = this.calcularMedia(vendas);
        console.log(`\n‚úÖ M√©dia de vendas: R$ ${media.toFixed(2)}`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);

        const maiorVenda = this.encontrarMaximo(vendas);
        console.log(`\n‚úÖ Maior venda: R$ ${maiorVenda.toFixed(2)}`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);

        const menorVenda = this.encontrarMinimo(vendas);
        console.log(`\n‚úÖ Menor venda: R$ ${menorVenda.toFixed(2)}`);
        console.log(`   Opera√ß√µes: ${this.operationCount}`);

        // An√°lise de dias com vendas acima da m√©dia
        this.resetCounter();
        const diasAcimaDaMedia = [];
        for (let i = 0; i < vendas.length; i++) {
            if (vendas[i] > media) {
                diasAcimaDaMedia.push({ dia: i + 1, valor: vendas[i] });
            }
            this.operationCount++;
        }

        console.log(`\n‚úÖ Dias com vendas acima da m√©dia: ${diasAcimaDaMedia.length}`);
        diasAcimaDaMedia.forEach(d => {
            console.log(`   Dia ${d.dia}: R$ ${d.valor.toFixed(2)}`);
        });
        console.log(`   Opera√ß√µes: ${this.operationCount}`);

        console.log("\n" + "‚îÅ".repeat(60));
        console.log("üìà Complexidade Total: O(n) - Linear");
        console.log(`   Elementos processados: ${vendas.length}`);
        console.log(`   Total de opera√ß√µes: ~${vendas.length * 5} (5 passagens)`);

        return {
            total,
            media,
            maiorVenda,
            menorVenda,
            diasAcimaDaMedia: diasAcimaDaMedia.length
        };
    }

    /**
     * USE CASE: PROCESSAMENTO DE TEXTO
     * Analisa um texto e retorna estat√≠sticas
     * @param {string} texto - Texto a ser analisado
     * @returns {Object} Estat√≠sticas do texto
     */
    analisarTexto(texto) {
        console.log("\nüìù AN√ÅLISE DE TEXTO - Use Case O(n)\n");
        console.log("Texto:", texto);
        console.log("‚îÅ".repeat(60));

        // Todas opera√ß√µes O(n) onde n = tamanho do texto

        this.resetCounter();
        let caracteres = texto.length;
        let vogais = 0;
        let consoantes = 0;
        let espacos = 0;
        let numeros = 0;

        const vogaisSet = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);

        for (let i = 0; i < texto.length; i++) {
            const char = texto[i];
            this.operationCount++;

            if (char === ' ') {
                espacos++;
            } else if (vogaisSet.has(char)) {
                vogais++;
            } else if (/[a-zA-Z]/.test(char)) {
                consoantes++;
            } else if (/[0-9]/.test(char)) {
                numeros++;
            }
        }

        const palavras = texto.trim().split(/\s+/).length;

        console.log(`\n‚úÖ Caracteres totais: ${caracteres}`);
        console.log(`‚úÖ Vogais: ${vogais}`);
        console.log(`‚úÖ Consoantes: ${consoantes}`);
        console.log(`‚úÖ Espa√ßos: ${espacos}`);
        console.log(`‚úÖ N√∫meros: ${numeros}`);
        console.log(`‚úÖ Palavras estimadas: ${palavras}`);
        console.log(`\nüìä Opera√ß√µes realizadas: ${this.operationCount}`);
        console.log("üìà Complexidade: O(n) onde n = n√∫mero de caracteres");

        return {
            caracteres,
            vogais,
            consoantes,
            espacos,
            numeros,
            palavras,
            operacoes: this.operationCount
        };
    }
}

/**
 * Demonstra√ß√£o com visualiza√ß√£o de complexidade
 */
function demonstrarComplexidadeLinear() {
    console.log("‚ïê".repeat(70));
    console.log("      DEMONSTRA√á√ÉO DE COMPLEXIDADE LINEAR - O(n)");
    console.log("‚ïê".repeat(70));

    const linear = new LinearComplexity();

    // Exemplo 1: Opera√ß√µes b√°sicas
    console.log("\nüî∏ EXEMPLO 1: Opera√ß√µes B√°sicas\n");

    const numeros = [10, 25, 5, 30, 15, 20, 8, 12];
    console.log("Array:", numeros);
    console.log("‚îÅ".repeat(60));

    const soma = linear.somaElementos(numeros);
    console.log(`\n1. Soma: ${soma} (${linear.getOperationCount()} opera√ß√µes)`);

    const maximo = linear.encontrarMaximo(numeros);
    console.log(`2. M√°ximo: ${maximo} (${linear.getOperationCount()} opera√ß√µes)`);

    const minimo = linear.encontrarMinimo(numeros);
    console.log(`3. M√≠nimo: ${minimo} (${linear.getOperationCount()} opera√ß√µes)`);

    const media = linear.calcularMedia(numeros);
    console.log(`4. M√©dia: ${media.toFixed(2)} (${linear.getOperationCount()} opera√ß√µes)`);

    // Exemplo 2: Busca e contagem
    console.log("\n\nüî∏ EXEMPLO 2: Busca e Contagem\n");

    const dados = [5, 3, 7, 3, 9, 3, 1, 3];
    console.log("Array:", dados);
    console.log("‚îÅ".repeat(60));

    const indice = linear.buscaLinear(dados, 7);
    console.log(`\n1. Buscar 7: encontrado no √≠ndice ${indice} (${linear.getOperationCount()} opera√ß√µes)`);

    const count = linear.contarOcorrencias(dados, 3);
    console.log(`2. Contar 3: aparece ${count} vezes (${linear.getOperationCount()} opera√ß√µes)`);

    // Exemplo 3: Transforma√ß√µes
    console.log("\n\nüî∏ EXEMPLO 3: Transforma√ß√µes\n");

    const original = [1, 2, 3, 4, 5];
    console.log("Array original:", original);
    console.log("‚îÅ".repeat(60));

    const pares = linear.filtrarPares(original);
    console.log(`\n1. Filtrar pares: [${pares}] (${linear.getOperationCount()} opera√ß√µes)`);

    const duplicados = linear.duplicarValores(original);
    console.log(`2. Duplicar: [${duplicados}] (${linear.getOperationCount()} opera√ß√µes)`);

    const revertido = linear.reverterArray(original);
    console.log(`3. Reverter: [${revertido}] (${linear.getOperationCount()} opera√ß√µes)`);

    // Exemplo 4: Remover duplicatas
    console.log("\n\nüî∏ EXEMPLO 4: Remover Duplicatas\n");

    const comDuplicatas = [1, 2, 2, 3, 4, 4, 4, 5, 1];
    console.log("Array com duplicatas:", comDuplicatas);
    console.log("‚îÅ".repeat(60));

    const semDuplicatas = linear.removerDuplicatas(comDuplicatas);
    console.log(`\nSem duplicatas: [${semDuplicatas}]`);
    console.log(`Opera√ß√µes: ${linear.getOperationCount()}`);
}

/**
 * An√°lise de performance com diferentes tamanhos
 */
function analisarPerformance() {
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("      AN√ÅLISE DE PERFORMANCE - O(n)");
    console.log("‚ïê".repeat(70));

    const linear = new LinearComplexity();
    const tamanhos = [100, 1000, 10000, 100000];

    console.log("\nTestando com diferentes tamanhos de array:\n");
    console.log("Tamanho".padEnd(15) + "Tempo (ms)".padEnd(15) + "Opera√ß√µes");
    console.log("‚îÄ".repeat(70));

    tamanhos.forEach(tamanho => {
        const arr = Array.from({ length: tamanho }, () => Math.floor(Math.random() * 100));

        const start = performance.now();
        linear.somaElementos(arr);
        const end = performance.now();

        const tempo = (end - start).toFixed(4);
        const ops = linear.getOperationCount();

        console.log(
            tamanho.toString().padEnd(15) +
            tempo.padEnd(15) +
            ops
        );
    });

    console.log("\nüí° Observe que o tempo cresce linearmente com o tamanho!");
    console.log("   Se n dobra, o tempo aproximadamente dobra (O(n))");
}

/**
 * Compara√ß√£o entre O(n) e O(n¬≤)
 */
function compararComplexidades() {
    console.log("\n\n" + "‚ïê".repeat(70));
    console.log("      COMPARA√á√ÉO: O(n) vs O(n¬≤)");
    console.log("‚ïê".repeat(70));

    const tamanhos = [100, 500, 1000];

    console.log("\nDiferen√ßa entre complexidade linear e quadr√°tica:\n");
    console.log("Tamanho".padEnd(12) + "O(n) ops".padEnd(15) + "O(n¬≤) ops".padEnd(15) + "Diferen√ßa");
    console.log("‚îÄ".repeat(70));

    tamanhos.forEach(n => {
        const operacoesLinear = n;
        const operacoesQuadratica = n * n;
        const diferenca = (operacoesQuadratica / operacoesLinear).toFixed(0);

        console.log(
            n.toString().padEnd(12) +
            operacoesLinear.toString().padEnd(15) +
            operacoesQuadratica.toString().padEnd(15) +
            `${diferenca}x mais opera√ß√µes`
        );
    });

    console.log("\nüí° O(n¬≤) cresce exponencialmente! Evite quando poss√≠vel.");
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXECU√á√ÉO
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Demonstra√ß√£o b√°sica
demonstrarComplexidadeLinear();

// Use Case 1: An√°lise de Vendas
console.log("\n\n" + "‚ïê".repeat(70));
console.log("      USE CASE 1: AN√ÅLISE DE VENDAS");
console.log("‚ïê".repeat(70));

const linear = new LinearComplexity();
const vendasSemanais = [1500.50, 2300.00, 1800.75, 2500.00, 1950.25, 2100.00, 3000.00];
linear.analisarVendas(vendasSemanais);

// Use Case 2: An√°lise de Texto
console.log("\n\n" + "‚ïê".repeat(70));
console.log("      USE CASE 2: PROCESSAMENTO DE TEXTO");
console.log("‚ïê".repeat(70));

const texto = "JavaScript √© uma linguagem poderosa! Vers√£o ES6 trouxe muitas melhorias.";
linear.analisarTexto(texto);

// An√°lise de Performance
analisarPerformance();

// Compara√ß√£o de Complexidades
compararComplexidades();

// Resumo Final
console.log("\n\n" + "‚ïê".repeat(70));
console.log("      RESUMO: COMPLEXIDADE LINEAR O(n)");
console.log("‚ïê".repeat(70));

console.log("\n‚úÖ Caracter√≠sticas:");
console.log("   ‚Ä¢ Tempo cresce proporcionalmente ao tamanho da entrada");
console.log("   ‚Ä¢ Um √∫nico loop sobre os dados");
console.log("   ‚Ä¢ Eficiente e escal√°vel");
console.log("   ‚Ä¢ Comum em opera√ß√µes de busca, soma, contagem");

console.log("\nüìä Quando usar:");
console.log("   ‚Ä¢ Processar cada elemento uma vez");
console.log("   ‚Ä¢ Busca em estruturas n√£o ordenadas");
console.log("   ‚Ä¢ Transforma√ß√µes simples de dados");
console.log("   ‚Ä¢ An√°lise e estat√≠sticas b√°sicas");

console.log("\n‚ö†Ô∏è  Evitar quando:");
console.log("   ‚Ä¢ Existem solu√ß√µes O(log n) dispon√≠veis");
console.log("   ‚Ä¢ Dados podem ser pr√©-processados");
console.log("   ‚Ä¢ Estruturas de dados especializadas podem ajudar");

console.log("\nüéØ Exemplos implementados nesta classe:");
console.log("   1. Soma de elementos");
console.log("   2. Encontrar m√°ximo/m√≠nimo");
console.log("   3. Busca linear");
console.log("   4. Contagem de ocorr√™ncias");
console.log("   5. Filtros e transforma√ß√µes");
console.log("   6. Remo√ß√£o de duplicatas");
console.log("   7. An√°lise de vendas");
console.log("   8. Processamento de texto");

console.log("\n" + "‚ïê".repeat(70));
